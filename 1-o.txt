مفهوم big O 

الگوریتمی که برای 10 ورودی به درستی کار میکند . آیا برای 100 ورودی هم به درستی کار میکند . 

در اصل برای سنجش پرفورمنس الگوریتم اسکیل پذیر استفاده میشود . 

برای مثال آیا روی یک رودخانه با عرض 10 متر یک پل درست کنیم آیا میتونیم از اون پل برای یک رودخانه 20 متری هم استفاده کنید ؟ 

یک لیست داریم که 10 تا عضو داره و باید مرتب بشه . 
یک الگوریتم مینویسیم واسش . الان این الگوریتم ما برای یک لیست با 100 عضو هم همون قدر سریع و کاربردی هست ؟؟ 
زمانی که الگوریتم بهینه و اسکیلبل نباشه برای ورودی های بزرگ کاربردی نیست . 
این مفهوم big O است . 


برای مثال دسترسی به عنصر یک آرایه توسط ایندکس بسیار راحت است و البته بسیار سریع است و اصلا فرقی نداره که آرایه ما چند عضو داشته باشه ما اگه خانه اول یا 0 رو بخوایم به سرعت خروجی رو خواهیم داشت . 
برای مثال در زبان برنامه نویسی دارت 
void main(){
printLastElement(List<int>.generate(1000300001, (index) => index));
}


printLastElement(List<int> list){

int middle = (0 + list.length / 2).floor();

print(list[middle]);
}


دسترسی به خانه وسط یک آرایه بزرگ رو خواستیم . و زمانی که طول میکشه فقط برای جنریت کردن آرایه هست . که این رو با o(1) نمایش میدیم  .


گفتیم این مفهوم برای این هست که بفهمیم آیا تعداد ورودی روی اجرای خروجی تاثیر داره یا نه که اینجا نداشت  .


برای مثال یک کد دیگه و یک الگوریتم دیگه داریم  : 
printElement(List<int> list){
  print("");
for (var i = 0; i < list.length; i++) {
  print(list[i]);
}

}

که از 3 عملیات تشکیل شده . 
1 - خط اول که حاوی یک print خالی است . 
2 - یک حلقه for که میاد و داخل تک تک خانه های لیست دریافتی دور میزنه و اندازه اش به اندازه لیست ورودی هست . 
3 - و یک print داخل حلقه for داریم . 
خب این به چه معناست ؟ 
در اصل پیچیدگی مرحله 2 که بالا توضیح دادیم به این صورت است که : 
O(n) در این مورد n همان تعداد لیست ورودی است . 
برای این به این صورت است که به صورت خطی افزایش پیدا میکند . برای مثال هر عملیات (هر دانه عملیات داخل حلقه 10 میلی ثانیه طول میکشد . ) حالا اگه لیست 10 عضو داشته باشد میشود 100 میلی ثانیه . اگه 50 عضو داشته باشد میشود 500 میلی ثانیه و به همین ترتیب ....

باید برای هر عملیات هم یکی به مقدار o(n)  اضافه شود . 2 مورد print در این کد وجود دارد پس باید در نهایت big o مساوی با n + 2 حساب شود . 

اما به دلیل اینکه 2 عددی ثابت است و فرق زیادی ندارد و تاثیر آنچنانی هم اینجا در الگوریتم ما ندارد نیازی به نوشتن آن نیست . 

























